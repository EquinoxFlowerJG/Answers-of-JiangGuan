# 第二周正式课–课后作业（1）
1. 实现函数fn，让其具有如下功能（百度二面）
```js
let res = fn(1,2)(3);
console.log(res); //=>6  1+2+3

// 答案：
function fn(a,b){
    let num = a + b;
    return function(c){
        return num + c;
    }
}
```
2. 写出下面代码输出的结果 （画图）
```js
var x=2;  // 4  16
var y={
    x:3,  // 15
    z:(function(x){  // 2 4 7 10
        this.x*=x;
        x+=2;
        return function(n){
            this.x*=n; 
            x+=3;
            console.log(x); 
        }
    })(x)
};
var m=y.z;
m(4);  // 7
y.z(5); // 10
console.log(x, y.x); // 16 15
```
3. 写出下面代码的输出结果（画图）
```js
function Fn(n,m) {
    n=n||0;
    m=m||0;
    this.x = n;
    this.y = m;
    this.getX = function () {
        console.log(this.x);
    }
    return n+m;
}
Fn.prototype.sum=function(){
    console.log(this.x+this.y);
}
Fn.prototype={
    getX:function(){
        this.x+=1;
        console.log(this.x);
    },
    getY:function(){
        this.y-=1;
        console.log(this.y);
    }
};
let f1 = new Fn(10,20);
let f2 = new Fn;
console.log(f1.getX === f2.getX);  // false
console.log(f1.getY === f2.getY); // true
console.log(f1.__proto__.getY === Fn.prototype.getY);  // true
console.log(Fn.prototype.getX === f2.getX); // false
console.log(f1.constructor); // Object
f1.getX();  // 10
Fn.prototype.getX();  // NaN
f2.getY();  // -1
Fn.prototype.getY();  // NaN
f1.sum(); // 报错
```
4. 写出下面代码输出的结果（画图 腾讯面试题）
```js
function fun(){
    this.a=0;
    this.b=function(){
        alert(this.a);
    }
}
fun.prototype={
    b:function(){
        this.a=20;
        alert(this.a);
    },
    c:function(){
        this.a=30;
        alert(this.a)
    }
}
var my_fun=new fun();
my_fun.b();  // "0"
my_fun.c();  // "30"
```
5. 写出下面代码输出的结果 （百度面试题）
```js
function C1(name) {
    if (name) {
        this.name = name;
    }
}
function C2(name) {
    this.name = name;
}
function C3(name) {
    this.name = name || 'join';
}
C1.prototype.name = 'Tom';
C2.prototype.name = 'Tom';
C3.prototype.name = 'Tom';
alert((new C1().name) + (new C2().name) + (new C3().name));  // 'Tomundefinedjoin'
```
6. 写出下面代码输出的结果 （画图）
```js
function Fn() {
    let a = 1;
    this.a = a;
}
Fn.prototype.say = function () {
    this.a = 2;
}
Fn.prototype = new Fn;  // 小心
let f1 = new Fn;
​
Fn.prototype.b = function () {
    this.a = 3;
};
console.log(f1.a);  // 1
console.log(f1.prototype);  // undefined 小心
console.log(f1.b);  // function(){this.a = 3;}
console.log(f1.hasOwnProperty('b'));  // false
console.log('b' in f1);  // truw
console.log(f1.constructor == Fn);  // true
```
7. 写出下面代码输出的结果 （画图）
```js
function Person() {
    this.name = 'zhufeng'
};
Person.prototype.getName = function () {
    console.log(this.name)
    console.log(this.age)
};
Person.prototype.age = 5000;

var per1 = new Person;
per1.getName();  // 'zhufeng' 5000
per1.age = 9;
per1.getName();  // 'zhufeng' 9
console.log(per1.age);  // 9
var per2 = new Person;
console.log(per2.age);  // 5000
```
8. 编写程序实现如下效果 （百度面试题）
```js
let n = 10;
let m = n.plus(10).minus(5);
console.log(m);//=>15（10+10-5）

// 答案：
function plus(num){
    // num = Number(num);
    // if(isNaN(num)){
        // alert('输入的不是数字，请输入数字');
    // }else{
        return this + num;
    // }  
}
function minus(num){
    // num = Number(num);
    // if(isNaN(num)){
        // alert('输入的不是数字，请输入数字');
    // }else{
        return this - num;
    // }
}
Number.prototype.plus = plus(num);
Number.prototype.minus = minus(num);
// 注：如果需要检测输入的是否为数字，可把注释掉的内容打开。确定是数字则不用。
```
9. 编写程序实现如下效果 （经典面试题）
```js
let ary = [12,23,12,13,13,12,23,14,8];
ary.unique().sort((a,b)=>a-b);
//=> 最后的ary等于[8,12,13,14,23]

// 答案：
function unique(){
    let temp = [];
    for(let i = 0; i < this.length; i++){
        temp.includes(this[i]) ? null : temp.push(this[i]);
    }
    return temp;
}
function sort(fun){
    for(let i = 0; i < this.length; i++){
        for(let j = i+1; j < this.length - 1; j++){
            if(this[i] > this[j]){
            let temp = this[i];
            this[i] = this[j];
            this[j] = temp;
            }
        }
    }
    if(fun === b-a){
        this = this.reserve();
    }
    return this;
}
Array.prototype.unique = unique();
Array.prototype.sort = sort(fun);
```
10. 一个url后面好多key:value，如localhost?key=val&key2=val2&key3=val3，封装一个函数 getParam(‘key’) 通过key获得相应等号后面的值（百度面试题）
```js
let url="locallhost?key1=val1&key2=val2&key3=val3";
console.log(url.getParam("key3")); 
//=>'val3'

// 答案：
function getParam(key){
    let str = this.split('?')[1].split('&');
    let obj = {};
    for(var i = 0; i < str.length; i++){
        obj[str[i].split('=')[0]] = str[i].split('=')[1];
    }
    return obj[key];
}
String.prototype.getParam = getParam(key);
```
# 附加作业（有难度，全部都是大公司原版面试题，不会做的可以空着）
1. 情人节福利题：重构内置new方法
<!-- FIXME:怎么做？ -->
```js 不会
function Dog(name) {
    this.name = name;
}
Dog.prototype.bark = function () {
    console.log('wangwang');
}
Dog.prototype.sayName = function () {
    console.log('my name is ' + this.name);
}
/*
let sanmao = new Dog('三毛');
sanmao.sayName();
sanmao.bark();
*/
//=>基于内置的new关键词，我们可以创建Dog的一个实例sanmao，实例可以调取原型上的属性和方法，现在的需求是：自己实现一个_new方法，也能模拟出内置new后的结果
function _new() {
    //=>完成你的代码

}
let sanmao = _new(Dog, '三毛');
sanmao.bark(); //=>"wangwang"
sanmao.sayName(); //=>"my name is 三毛"
console.log(sanmao instanceof Dog); //=>true

// 答案：
function _new(fun,name){
    
}
```
2. 下面代码a在什么值情况下会输出1
<!-- FIXME:怎么做？ -->
```js
var a = ?;
if (a == 1 && a == 2 && a == 3) {
    console.log(1);
}

// 答案：
a = 
```
3. 下面代码的输出结果？为什么？
<!-- FIXME:怎么做？ -->
```js
let obj = {
    2: 3,
    3: 4,
    length: 2,
    push: Array.prototype.push
}
obj.push(1);  // 2 push方法的返回值是数组的长度，但有重复属性名，此处为修改了2: 1
obj.push(2);  // 2 有重复的属性名，此处为修改属性3的属性值
console.log(obj);  // {2: 1, 3: 2, }
```
4. 阿里超经典面试题
```js
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();  // 2
getName();  // 
Foo().getName();  // 1
getName();  // 
new Foo.getName();
new Foo().getName();  // 3
new new Foo().getName();
```